# Notes on Express.js

## Package Management
- When we write `npm i express`, all the code of Express.js goes inside `node_modules`.
- `node_modules` is a place where all installed packages are stored.
- A dependency of this project gets added in `package.json`.
- We also have the concept of transitive dependency, which refers to the dependencies of dependencies (e.g., Express.js is dependent on other dependencies).

### Versioning
- **Versioning Format**: `4.19.2` (major(4) | minor(19) | patch(2))
- Minor changes are backward compatible.
- Using `~` means to auto-upgrade.
- To lock the version, we have `package-lock.json`, which tells the exact version we are using.
- `package.json` specifies the versioning system to be used.

### Global Installation
- `-g` means it is installed at the global level.
- `nodemon` automatically refreshes the server, so install that package.

## Dependencies
- **Definition**: In programming, dependencies are external libraries, frameworks, or tools that your project relies on to work. These are additional pieces of code written by others that your project "depends on" to provide certain functionality, so you don’t have to build everything from scratch.

## Routing in Express.js
- The order of the routes matters a lot.

### Example Routes
```javascript
// This will only handle GET calls to /user
app.get("/user", (req, res) => {
    res.send({ firstName: "mutku", lastName: "chutku" });
});

app.post("/user", (req, res) => {
    res.send("Data successfully sent to database");
});

// This will match all HTTP method API calls to /test
app.use("/test", (req, res) => {
    res.send("Hello from the Server!");
});
```

- In Express, `app.use()` is used to apply middleware or match all requests starting with the specified path. Since `/` matches all routes as a prefix, it gets triggered first, and your other routes (e.g., `/hello` and `/test`) are never reached.

### Wildcards
- You can use `*` to match any route that starts with or contains a certain prefix, or to match any route entirely.
```javascript
app.use("/api/*", (req, res) => {
    res.send("API Endpoint Accessed!");
});
```
- Example Matches:
  - `/api/users` → Matches, responds with "API Endpoint Accessed!".
  - `/api/products/details` → Matches, responds with "API Endpoint Accessed!".
  - `/api` → Does not match because the wildcard expects something after `/api/`.

## Query Parameters
- Example URL: `http://localhost:3000/search?category=electronics&price=low`
```javascript
app.get('/search', (req, res) => {
    const { category, price } = req.query;
    res.send(`Category: ${category}, Price: ${price}`);
});
```

## Request Parameters

app.get('/search', (req, res) => {
  const { category, price } = req.query;
  res.send(`Category: ${category}, Price: ${price}`);
});

- req params
app.get("/user/:userId/:name/:password",(req,res)=>{
    console.log(req.params);
    res.send({firstName:"mutku",lastname:"chutku"});
})

// New Chapter
- route handler
- if you keep a route handler empty it will go to infinite loop.

app.use("/user",(req,res,next)=>{
    //route handler
})

- next() function calls the next middleware in the stack.
- if we keep the first middleware empty in the stack and we add next() to it then the next middleware/route handler code will get executed.

app.use("/user",(req,res,next)=>{
    //route handler
    //if we keep route handler empty or we dont send a response to the user
    //it will go into infinite loop
    console.log("Handling the route user!!");
    next();
    res.send("Response");
},(req,res) => {
    console.log("Handling the routes user 2!!");
    res.send("2nd Response!!");
}
)

- express tells you can have as many handler you want but response should be send.
- try this app.use("/route",rH,[rH2,rH3],rH4,rH5)

- What is a middleware ?
    Middleware in Express.js refers to functions that have access to the request (req) object, 
    the response (res) object, and the next() function in the application's request-response cycle. 

    - Middleware functions can perform the following tasks:
    - Execute any code.
    - Modify the req and res objects.
    - End the request-response cycle.
    - Call the next() function to pass control to the next middleware.

- How express Js basically handles request behind the scenes?


- difference between app.use and app.all.

- clean way of doing authorization,importance of middleware.
- Handle Auth middleware for all GET POST,... requests.

        app.use("/admin",(req,res,next)=>{
            console.log("Admin auth is getting checked");
            const token = "xyz";
            const isAdminAuthorized = token === "xyz";
            if(!isAdminAuthorized){
                res.status(401).send("Unauthorized access");
            }
            else{
                next();
            }
        })

        app.get("/admin/getAllData",(req,res)=>{
            res.send("All Data send");
        })

        app.get("/admin/deleteUser",(req,res)=>{
            res.send("Deleted a user");
        })
- write a dummy auth middleware for admin
- write a dummy auth middleware for all user routes,except /user/login
- Error Handling using a app.use("/",(err,req,res,next)={})

- connecting application to database
- installing mongoose library
- connect your application to the database "Connection-url"/connectify
- call the connection function in app.js
- listening on port ,only when database connection is established

- creating schema
- first we create schema then we create model out of it ,then we keep creating instances as per our need.
- database -> collection -> document

- JS object vs JSON (difference)
- Add the express.json middleware to your app
- Make your signUp API 

- Added .env file for keeping secrets
- installed dotenv package 
- explore options in a Model.findOneAndUpdate method,explore more about it.

- validations and santizing our data
- validations on our database.
- adding custom validation function in our schema
- adding options while doing update ,and setting validations to true 
- adding timestamps in our schema
- restricted updates
- add api level validations on patch requests and signup post api
- data sanitizng : add api validations for each field
- using validator library which makes validation easy for us
- explore validator library function and use validator functions for password,email.
- never trust req.body.

- authentication
- validate data in Signup Api
- install bcrypt package
- Create PasswordHash using bcrypt.hash and save the user encrypted password
- create login api
- compare passwords and throw errors if email or password is invalid